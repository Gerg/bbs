// Code generated by protoc-gen-gogo.
// source: actions.proto
// DO NOT EDIT!

/*
	Package models is a generated protocol buffer package.

	It is generated from these files:
		actions.proto
		actual_lrp.proto
		desired_lrp.proto
		domain.proto
		environment_variables.proto
		error.proto
		events.proto
		modification_tag.proto

	It has these top-level messages:
		Action
		DownloadAction
		UploadAction
		RunAction
		TimeoutAction
		EmitProgressAction
		TryAction
		ParallelAction
		SerialAction
		CodependentAction
		ResourceLimits
*/
package models

import proto "github.com/gogo/protobuf/proto"
import math "math"

// discarding unused import gogoproto "github.com/gogo/protobuf/gogoproto/gogo.pb"

import io "io"
import fmt "fmt"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = math.Inf

type Action struct {
	DownloadAction     *DownloadAction     `protobuf:"bytes,1,opt,name=download_action" json:"download,omitempty"`
	UploadAction       *UploadAction       `protobuf:"bytes,2,opt,name=upload_action" json:"upload,omitempty"`
	RunAction          *RunAction          `protobuf:"bytes,3,opt,name=run_action" json:"run,omitempty"`
	TimeoutAction      *TimeoutAction      `protobuf:"bytes,4,opt,name=timeout_action" json:"timeout,omitempty"`
	EmitProgressAction *EmitProgressAction `protobuf:"bytes,5,opt,name=emit_progress_action" json:"emit_progress,omitempty"`
	TryAction          *TryAction          `protobuf:"bytes,6,opt,name=try_action" json:"try,omitempty"`
	ParallelAction     *ParallelAction     `protobuf:"bytes,7,opt,name=parallel_action" json:"parallel,omitempty"`
	SerialAction       *SerialAction       `protobuf:"bytes,8,opt,name=serial_action" json:"serial,omitempty"`
	CodependentAction  *CodependentAction  `protobuf:"bytes,9,opt,name=codependent_action" json:"codependent,omitempty"`
}

func (m *Action) Reset()         { *m = Action{} }
func (m *Action) String() string { return proto.CompactTextString(m) }
func (*Action) ProtoMessage()    {}

func (m *Action) GetDownloadAction() *DownloadAction {
	if m != nil {
		return m.DownloadAction
	}
	return nil
}

func (m *Action) GetUploadAction() *UploadAction {
	if m != nil {
		return m.UploadAction
	}
	return nil
}

func (m *Action) GetRunAction() *RunAction {
	if m != nil {
		return m.RunAction
	}
	return nil
}

func (m *Action) GetTimeoutAction() *TimeoutAction {
	if m != nil {
		return m.TimeoutAction
	}
	return nil
}

func (m *Action) GetEmitProgressAction() *EmitProgressAction {
	if m != nil {
		return m.EmitProgressAction
	}
	return nil
}

func (m *Action) GetTryAction() *TryAction {
	if m != nil {
		return m.TryAction
	}
	return nil
}

func (m *Action) GetParallelAction() *ParallelAction {
	if m != nil {
		return m.ParallelAction
	}
	return nil
}

func (m *Action) GetSerialAction() *SerialAction {
	if m != nil {
		return m.SerialAction
	}
	return nil
}

func (m *Action) GetCodependentAction() *CodependentAction {
	if m != nil {
		return m.CodependentAction
	}
	return nil
}

type DownloadAction struct {
	Artifact  *string `protobuf:"bytes,1,opt,name=artifact" json:"artifact,omitempty"`
	From      *string `protobuf:"bytes,2,opt,name=from" json:"from,omitempty"`
	To        *string `protobuf:"bytes,3,opt,name=to" json:"to,omitempty"`
	CacheKey  *string `protobuf:"bytes,4,opt,name=cache_key" json:"cache_key,omitempty"`
	LogSource *string `protobuf:"bytes,5,opt,name=log_source" json:"log_source,omitempty"`
	User      *string `protobuf:"bytes,6,opt,name=user" json:"user,omitempty"`
}

func (m *DownloadAction) Reset()         { *m = DownloadAction{} }
func (m *DownloadAction) String() string { return proto.CompactTextString(m) }
func (*DownloadAction) ProtoMessage()    {}

func (m *DownloadAction) GetArtifact() string {
	if m != nil && m.Artifact != nil {
		return *m.Artifact
	}
	return ""
}

func (m *DownloadAction) GetFrom() string {
	if m != nil && m.From != nil {
		return *m.From
	}
	return ""
}

func (m *DownloadAction) GetTo() string {
	if m != nil && m.To != nil {
		return *m.To
	}
	return ""
}

func (m *DownloadAction) GetCacheKey() string {
	if m != nil && m.CacheKey != nil {
		return *m.CacheKey
	}
	return ""
}

func (m *DownloadAction) GetLogSource() string {
	if m != nil && m.LogSource != nil {
		return *m.LogSource
	}
	return ""
}

func (m *DownloadAction) GetUser() string {
	if m != nil && m.User != nil {
		return *m.User
	}
	return ""
}

type UploadAction struct {
	Artifact  *string `protobuf:"bytes,1,opt,name=artifact" json:"artifact,omitempty"`
	From      *string `protobuf:"bytes,2,opt,name=from" json:"from,omitempty"`
	To        *string `protobuf:"bytes,3,opt,name=to" json:"to,omitempty"`
	LogSource *string `protobuf:"bytes,4,opt,name=log_source" json:"log_source,omitempty"`
	User      *string `protobuf:"bytes,5,opt,name=user" json:"user,omitempty"`
}

func (m *UploadAction) Reset()         { *m = UploadAction{} }
func (m *UploadAction) String() string { return proto.CompactTextString(m) }
func (*UploadAction) ProtoMessage()    {}

func (m *UploadAction) GetArtifact() string {
	if m != nil && m.Artifact != nil {
		return *m.Artifact
	}
	return ""
}

func (m *UploadAction) GetFrom() string {
	if m != nil && m.From != nil {
		return *m.From
	}
	return ""
}

func (m *UploadAction) GetTo() string {
	if m != nil && m.To != nil {
		return *m.To
	}
	return ""
}

func (m *UploadAction) GetLogSource() string {
	if m != nil && m.LogSource != nil {
		return *m.LogSource
	}
	return ""
}

func (m *UploadAction) GetUser() string {
	if m != nil && m.User != nil {
		return *m.User
	}
	return ""
}

type RunAction struct {
	Path           *string                `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	Args           []string               `protobuf:"bytes,2,rep,name=args" json:"args,omitempty"`
	Dir            *string                `protobuf:"bytes,3,opt,name=dir" json:"dir,omitempty"`
	Env            []*EnvironmentVariable `protobuf:"bytes,4,rep,name=env" json:"env,omitempty"`
	ResourceLimits *ResourceLimits        `protobuf:"bytes,5,opt,name=resource_limits" json:"resource_limits,omitempty"`
	User           *string                `protobuf:"bytes,6,opt,name=user" json:"user,omitempty"`
	LogSource      *string                `protobuf:"bytes,7,opt,name=log_source" json:"log_source,omitempty"`
}

func (m *RunAction) Reset()         { *m = RunAction{} }
func (m *RunAction) String() string { return proto.CompactTextString(m) }
func (*RunAction) ProtoMessage()    {}

func (m *RunAction) GetPath() string {
	if m != nil && m.Path != nil {
		return *m.Path
	}
	return ""
}

func (m *RunAction) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *RunAction) GetDir() string {
	if m != nil && m.Dir != nil {
		return *m.Dir
	}
	return ""
}

func (m *RunAction) GetEnv() []*EnvironmentVariable {
	if m != nil {
		return m.Env
	}
	return nil
}

func (m *RunAction) GetResourceLimits() *ResourceLimits {
	if m != nil {
		return m.ResourceLimits
	}
	return nil
}

func (m *RunAction) GetUser() string {
	if m != nil && m.User != nil {
		return *m.User
	}
	return ""
}

func (m *RunAction) GetLogSource() string {
	if m != nil && m.LogSource != nil {
		return *m.LogSource
	}
	return ""
}

type TimeoutAction struct {
	Action    *Action `protobuf:"bytes,1,opt,name=action" json:"action,omitempty"`
	Timeout   *int64  `protobuf:"varint,2,opt,name=timeout" json:"timeout,omitempty"`
	LogSource *string `protobuf:"bytes,3,opt,name=log_source" json:"log_source,omitempty"`
}

func (m *TimeoutAction) Reset()         { *m = TimeoutAction{} }
func (m *TimeoutAction) String() string { return proto.CompactTextString(m) }
func (*TimeoutAction) ProtoMessage()    {}

func (m *TimeoutAction) GetAction() *Action {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *TimeoutAction) GetTimeout() int64 {
	if m != nil && m.Timeout != nil {
		return *m.Timeout
	}
	return 0
}

func (m *TimeoutAction) GetLogSource() string {
	if m != nil && m.LogSource != nil {
		return *m.LogSource
	}
	return ""
}

type EmitProgressAction struct {
	Action               *Action `protobuf:"bytes,1,opt,name=action" json:"action,omitempty"`
	StartMessage         *string `protobuf:"bytes,2,opt,name=start_message" json:"start_message,omitempty"`
	SuccessMessage       *string `protobuf:"bytes,3,opt,name=success_message" json:"success_message,omitempty"`
	FailureMessagePrefix *string `protobuf:"bytes,4,opt,name=failure_message_prefix" json:"failure_message_prefix,omitempty"`
	LogSource            *string `protobuf:"bytes,5,opt,name=log_source" json:"log_source,omitempty"`
}

func (m *EmitProgressAction) Reset()         { *m = EmitProgressAction{} }
func (m *EmitProgressAction) String() string { return proto.CompactTextString(m) }
func (*EmitProgressAction) ProtoMessage()    {}

func (m *EmitProgressAction) GetAction() *Action {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *EmitProgressAction) GetStartMessage() string {
	if m != nil && m.StartMessage != nil {
		return *m.StartMessage
	}
	return ""
}

func (m *EmitProgressAction) GetSuccessMessage() string {
	if m != nil && m.SuccessMessage != nil {
		return *m.SuccessMessage
	}
	return ""
}

func (m *EmitProgressAction) GetFailureMessagePrefix() string {
	if m != nil && m.FailureMessagePrefix != nil {
		return *m.FailureMessagePrefix
	}
	return ""
}

func (m *EmitProgressAction) GetLogSource() string {
	if m != nil && m.LogSource != nil {
		return *m.LogSource
	}
	return ""
}

type TryAction struct {
	Action    *Action `protobuf:"bytes,1,opt,name=action" json:"action,omitempty"`
	LogSource *string `protobuf:"bytes,2,opt,name=log_source" json:"log_source,omitempty"`
}

func (m *TryAction) Reset()         { *m = TryAction{} }
func (m *TryAction) String() string { return proto.CompactTextString(m) }
func (*TryAction) ProtoMessage()    {}

func (m *TryAction) GetAction() *Action {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *TryAction) GetLogSource() string {
	if m != nil && m.LogSource != nil {
		return *m.LogSource
	}
	return ""
}

type ParallelAction struct {
	Actions   []*Action `protobuf:"bytes,1,rep,name=actions" json:"actions,omitempty"`
	LogSource *string   `protobuf:"bytes,2,opt,name=log_source" json:"log_source,omitempty"`
}

func (m *ParallelAction) Reset()         { *m = ParallelAction{} }
func (m *ParallelAction) String() string { return proto.CompactTextString(m) }
func (*ParallelAction) ProtoMessage()    {}

func (m *ParallelAction) GetActions() []*Action {
	if m != nil {
		return m.Actions
	}
	return nil
}

func (m *ParallelAction) GetLogSource() string {
	if m != nil && m.LogSource != nil {
		return *m.LogSource
	}
	return ""
}

type SerialAction struct {
	Actions   []*Action `protobuf:"bytes,1,rep,name=actions" json:"actions,omitempty"`
	LogSource *string   `protobuf:"bytes,2,opt,name=log_source" json:"log_source,omitempty"`
}

func (m *SerialAction) Reset()         { *m = SerialAction{} }
func (m *SerialAction) String() string { return proto.CompactTextString(m) }
func (*SerialAction) ProtoMessage()    {}

func (m *SerialAction) GetActions() []*Action {
	if m != nil {
		return m.Actions
	}
	return nil
}

func (m *SerialAction) GetLogSource() string {
	if m != nil && m.LogSource != nil {
		return *m.LogSource
	}
	return ""
}

type CodependentAction struct {
	Actions   []*Action `protobuf:"bytes,1,rep,name=actions" json:"actions,omitempty"`
	LogSource *string   `protobuf:"bytes,2,opt,name=log_source" json:"log_source,omitempty"`
}

func (m *CodependentAction) Reset()         { *m = CodependentAction{} }
func (m *CodependentAction) String() string { return proto.CompactTextString(m) }
func (*CodependentAction) ProtoMessage()    {}

func (m *CodependentAction) GetActions() []*Action {
	if m != nil {
		return m.Actions
	}
	return nil
}

func (m *CodependentAction) GetLogSource() string {
	if m != nil && m.LogSource != nil {
		return *m.LogSource
	}
	return ""
}

type ResourceLimits struct {
	Nofile *uint64 `protobuf:"varint,1,opt,name=nofile" json:"nofile,omitempty"`
}

func (m *ResourceLimits) Reset()         { *m = ResourceLimits{} }
func (m *ResourceLimits) String() string { return proto.CompactTextString(m) }
func (*ResourceLimits) ProtoMessage()    {}

func (m *ResourceLimits) GetNofile() uint64 {
	if m != nil && m.Nofile != nil {
		return *m.Nofile
	}
	return 0
}

func init() {
}
func (m *Action) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownloadAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DownloadAction == nil {
				m.DownloadAction = &DownloadAction{}
			}
			if err := m.DownloadAction.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UploadAction == nil {
				m.UploadAction = &UploadAction{}
			}
			if err := m.UploadAction.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RunAction == nil {
				m.RunAction = &RunAction{}
			}
			if err := m.RunAction.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeoutAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TimeoutAction == nil {
				m.TimeoutAction = &TimeoutAction{}
			}
			if err := m.TimeoutAction.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmitProgressAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EmitProgressAction == nil {
				m.EmitProgressAction = &EmitProgressAction{}
			}
			if err := m.EmitProgressAction.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TryAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TryAction == nil {
				m.TryAction = &TryAction{}
			}
			if err := m.TryAction.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParallelAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ParallelAction == nil {
				m.ParallelAction = &ParallelAction{}
			}
			if err := m.ParallelAction.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerialAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SerialAction == nil {
				m.SerialAction = &SerialAction{}
			}
			if err := m.SerialAction.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CodependentAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CodependentAction == nil {
				m.CodependentAction = &CodependentAction{}
			}
			if err := m.CodependentAction.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipActions(data[iNdEx:])
			if err != nil {
				return err
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *DownloadAction) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Artifact", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Artifact = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.From = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.To = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.CacheKey = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogSource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.LogSource = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.User = &s
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipActions(data[iNdEx:])
			if err != nil {
				return err
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *UploadAction) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Artifact", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Artifact = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.From = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.To = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogSource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.LogSource = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.User = &s
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipActions(data[iNdEx:])
			if err != nil {
				return err
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *RunAction) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Path = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dir", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Dir = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Env = append(m.Env, &EnvironmentVariable{})
			if err := m.Env[len(m.Env)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourceLimits == nil {
				m.ResourceLimits = &ResourceLimits{}
			}
			if err := m.ResourceLimits.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.User = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogSource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.LogSource = &s
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipActions(data[iNdEx:])
			if err != nil {
				return err
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *TimeoutAction) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Action == nil {
				m.Action = &Action{}
			}
			if err := m.Action.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Timeout = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogSource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.LogSource = &s
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipActions(data[iNdEx:])
			if err != nil {
				return err
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *EmitProgressAction) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Action == nil {
				m.Action = &Action{}
			}
			if err := m.Action.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.StartMessage = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuccessMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.SuccessMessage = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailureMessagePrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.FailureMessagePrefix = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogSource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.LogSource = &s
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipActions(data[iNdEx:])
			if err != nil {
				return err
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *TryAction) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Action == nil {
				m.Action = &Action{}
			}
			if err := m.Action.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogSource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.LogSource = &s
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipActions(data[iNdEx:])
			if err != nil {
				return err
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *ParallelAction) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Actions = append(m.Actions, &Action{})
			if err := m.Actions[len(m.Actions)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogSource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.LogSource = &s
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipActions(data[iNdEx:])
			if err != nil {
				return err
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *SerialAction) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Actions = append(m.Actions, &Action{})
			if err := m.Actions[len(m.Actions)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogSource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.LogSource = &s
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipActions(data[iNdEx:])
			if err != nil {
				return err
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *CodependentAction) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Actions = append(m.Actions, &Action{})
			if err := m.Actions[len(m.Actions)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogSource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.LogSource = &s
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipActions(data[iNdEx:])
			if err != nil {
				return err
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *ResourceLimits) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nofile", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Nofile = &v
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipActions(data[iNdEx:])
			if err != nil {
				return err
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func skipActions(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for {
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipActions(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}
func (this *Action) GetValue() interface{} {
	if this.DownloadAction != nil {
		return this.DownloadAction
	}
	if this.UploadAction != nil {
		return this.UploadAction
	}
	if this.RunAction != nil {
		return this.RunAction
	}
	if this.TimeoutAction != nil {
		return this.TimeoutAction
	}
	if this.EmitProgressAction != nil {
		return this.EmitProgressAction
	}
	if this.TryAction != nil {
		return this.TryAction
	}
	if this.ParallelAction != nil {
		return this.ParallelAction
	}
	if this.SerialAction != nil {
		return this.SerialAction
	}
	if this.CodependentAction != nil {
		return this.CodependentAction
	}
	return nil
}

func (this *Action) SetValue(value interface{}) bool {
	switch vt := value.(type) {
	case *DownloadAction:
		this.DownloadAction = vt
	case *UploadAction:
		this.UploadAction = vt
	case *RunAction:
		this.RunAction = vt
	case *TimeoutAction:
		this.TimeoutAction = vt
	case *EmitProgressAction:
		this.EmitProgressAction = vt
	case *TryAction:
		this.TryAction = vt
	case *ParallelAction:
		this.ParallelAction = vt
	case *SerialAction:
		this.SerialAction = vt
	case *CodependentAction:
		this.CodependentAction = vt
	default:
		return false
	}
	return true
}
func (m *Action) Size() (n int) {
	var l int
	_ = l
	if m.DownloadAction != nil {
		l = m.DownloadAction.Size()
		n += 1 + l + sovActions(uint64(l))
	}
	if m.UploadAction != nil {
		l = m.UploadAction.Size()
		n += 1 + l + sovActions(uint64(l))
	}
	if m.RunAction != nil {
		l = m.RunAction.Size()
		n += 1 + l + sovActions(uint64(l))
	}
	if m.TimeoutAction != nil {
		l = m.TimeoutAction.Size()
		n += 1 + l + sovActions(uint64(l))
	}
	if m.EmitProgressAction != nil {
		l = m.EmitProgressAction.Size()
		n += 1 + l + sovActions(uint64(l))
	}
	if m.TryAction != nil {
		l = m.TryAction.Size()
		n += 1 + l + sovActions(uint64(l))
	}
	if m.ParallelAction != nil {
		l = m.ParallelAction.Size()
		n += 1 + l + sovActions(uint64(l))
	}
	if m.SerialAction != nil {
		l = m.SerialAction.Size()
		n += 1 + l + sovActions(uint64(l))
	}
	if m.CodependentAction != nil {
		l = m.CodependentAction.Size()
		n += 1 + l + sovActions(uint64(l))
	}
	return n
}

func (m *DownloadAction) Size() (n int) {
	var l int
	_ = l
	if m.Artifact != nil {
		l = len(*m.Artifact)
		n += 1 + l + sovActions(uint64(l))
	}
	if m.From != nil {
		l = len(*m.From)
		n += 1 + l + sovActions(uint64(l))
	}
	if m.To != nil {
		l = len(*m.To)
		n += 1 + l + sovActions(uint64(l))
	}
	if m.CacheKey != nil {
		l = len(*m.CacheKey)
		n += 1 + l + sovActions(uint64(l))
	}
	if m.LogSource != nil {
		l = len(*m.LogSource)
		n += 1 + l + sovActions(uint64(l))
	}
	if m.User != nil {
		l = len(*m.User)
		n += 1 + l + sovActions(uint64(l))
	}
	return n
}

func (m *UploadAction) Size() (n int) {
	var l int
	_ = l
	if m.Artifact != nil {
		l = len(*m.Artifact)
		n += 1 + l + sovActions(uint64(l))
	}
	if m.From != nil {
		l = len(*m.From)
		n += 1 + l + sovActions(uint64(l))
	}
	if m.To != nil {
		l = len(*m.To)
		n += 1 + l + sovActions(uint64(l))
	}
	if m.LogSource != nil {
		l = len(*m.LogSource)
		n += 1 + l + sovActions(uint64(l))
	}
	if m.User != nil {
		l = len(*m.User)
		n += 1 + l + sovActions(uint64(l))
	}
	return n
}

func (m *RunAction) Size() (n int) {
	var l int
	_ = l
	if m.Path != nil {
		l = len(*m.Path)
		n += 1 + l + sovActions(uint64(l))
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			l = len(s)
			n += 1 + l + sovActions(uint64(l))
		}
	}
	if m.Dir != nil {
		l = len(*m.Dir)
		n += 1 + l + sovActions(uint64(l))
	}
	if len(m.Env) > 0 {
		for _, e := range m.Env {
			l = e.Size()
			n += 1 + l + sovActions(uint64(l))
		}
	}
	if m.ResourceLimits != nil {
		l = m.ResourceLimits.Size()
		n += 1 + l + sovActions(uint64(l))
	}
	if m.User != nil {
		l = len(*m.User)
		n += 1 + l + sovActions(uint64(l))
	}
	if m.LogSource != nil {
		l = len(*m.LogSource)
		n += 1 + l + sovActions(uint64(l))
	}
	return n
}

func (m *TimeoutAction) Size() (n int) {
	var l int
	_ = l
	if m.Action != nil {
		l = m.Action.Size()
		n += 1 + l + sovActions(uint64(l))
	}
	if m.Timeout != nil {
		n += 1 + sovActions(uint64(*m.Timeout))
	}
	if m.LogSource != nil {
		l = len(*m.LogSource)
		n += 1 + l + sovActions(uint64(l))
	}
	return n
}

func (m *EmitProgressAction) Size() (n int) {
	var l int
	_ = l
	if m.Action != nil {
		l = m.Action.Size()
		n += 1 + l + sovActions(uint64(l))
	}
	if m.StartMessage != nil {
		l = len(*m.StartMessage)
		n += 1 + l + sovActions(uint64(l))
	}
	if m.SuccessMessage != nil {
		l = len(*m.SuccessMessage)
		n += 1 + l + sovActions(uint64(l))
	}
	if m.FailureMessagePrefix != nil {
		l = len(*m.FailureMessagePrefix)
		n += 1 + l + sovActions(uint64(l))
	}
	if m.LogSource != nil {
		l = len(*m.LogSource)
		n += 1 + l + sovActions(uint64(l))
	}
	return n
}

func (m *TryAction) Size() (n int) {
	var l int
	_ = l
	if m.Action != nil {
		l = m.Action.Size()
		n += 1 + l + sovActions(uint64(l))
	}
	if m.LogSource != nil {
		l = len(*m.LogSource)
		n += 1 + l + sovActions(uint64(l))
	}
	return n
}

func (m *ParallelAction) Size() (n int) {
	var l int
	_ = l
	if len(m.Actions) > 0 {
		for _, e := range m.Actions {
			l = e.Size()
			n += 1 + l + sovActions(uint64(l))
		}
	}
	if m.LogSource != nil {
		l = len(*m.LogSource)
		n += 1 + l + sovActions(uint64(l))
	}
	return n
}

func (m *SerialAction) Size() (n int) {
	var l int
	_ = l
	if len(m.Actions) > 0 {
		for _, e := range m.Actions {
			l = e.Size()
			n += 1 + l + sovActions(uint64(l))
		}
	}
	if m.LogSource != nil {
		l = len(*m.LogSource)
		n += 1 + l + sovActions(uint64(l))
	}
	return n
}

func (m *CodependentAction) Size() (n int) {
	var l int
	_ = l
	if len(m.Actions) > 0 {
		for _, e := range m.Actions {
			l = e.Size()
			n += 1 + l + sovActions(uint64(l))
		}
	}
	if m.LogSource != nil {
		l = len(*m.LogSource)
		n += 1 + l + sovActions(uint64(l))
	}
	return n
}

func (m *ResourceLimits) Size() (n int) {
	var l int
	_ = l
	if m.Nofile != nil {
		n += 1 + sovActions(uint64(*m.Nofile))
	}
	return n
}

func sovActions(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozActions(x uint64) (n int) {
	return sovActions(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Action) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Action) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DownloadAction != nil {
		data[i] = 0xa
		i++
		i = encodeVarintActions(data, i, uint64(m.DownloadAction.Size()))
		n1, err := m.DownloadAction.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.UploadAction != nil {
		data[i] = 0x12
		i++
		i = encodeVarintActions(data, i, uint64(m.UploadAction.Size()))
		n2, err := m.UploadAction.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.RunAction != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintActions(data, i, uint64(m.RunAction.Size()))
		n3, err := m.RunAction.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.TimeoutAction != nil {
		data[i] = 0x22
		i++
		i = encodeVarintActions(data, i, uint64(m.TimeoutAction.Size()))
		n4, err := m.TimeoutAction.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.EmitProgressAction != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintActions(data, i, uint64(m.EmitProgressAction.Size()))
		n5, err := m.EmitProgressAction.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.TryAction != nil {
		data[i] = 0x32
		i++
		i = encodeVarintActions(data, i, uint64(m.TryAction.Size()))
		n6, err := m.TryAction.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.ParallelAction != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintActions(data, i, uint64(m.ParallelAction.Size()))
		n7, err := m.ParallelAction.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.SerialAction != nil {
		data[i] = 0x42
		i++
		i = encodeVarintActions(data, i, uint64(m.SerialAction.Size()))
		n8, err := m.SerialAction.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.CodependentAction != nil {
		data[i] = 0x4a
		i++
		i = encodeVarintActions(data, i, uint64(m.CodependentAction.Size()))
		n9, err := m.CodependentAction.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *DownloadAction) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DownloadAction) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Artifact != nil {
		data[i] = 0xa
		i++
		i = encodeVarintActions(data, i, uint64(len(*m.Artifact)))
		i += copy(data[i:], *m.Artifact)
	}
	if m.From != nil {
		data[i] = 0x12
		i++
		i = encodeVarintActions(data, i, uint64(len(*m.From)))
		i += copy(data[i:], *m.From)
	}
	if m.To != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintActions(data, i, uint64(len(*m.To)))
		i += copy(data[i:], *m.To)
	}
	if m.CacheKey != nil {
		data[i] = 0x22
		i++
		i = encodeVarintActions(data, i, uint64(len(*m.CacheKey)))
		i += copy(data[i:], *m.CacheKey)
	}
	if m.LogSource != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintActions(data, i, uint64(len(*m.LogSource)))
		i += copy(data[i:], *m.LogSource)
	}
	if m.User != nil {
		data[i] = 0x32
		i++
		i = encodeVarintActions(data, i, uint64(len(*m.User)))
		i += copy(data[i:], *m.User)
	}
	return i, nil
}

func (m *UploadAction) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UploadAction) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Artifact != nil {
		data[i] = 0xa
		i++
		i = encodeVarintActions(data, i, uint64(len(*m.Artifact)))
		i += copy(data[i:], *m.Artifact)
	}
	if m.From != nil {
		data[i] = 0x12
		i++
		i = encodeVarintActions(data, i, uint64(len(*m.From)))
		i += copy(data[i:], *m.From)
	}
	if m.To != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintActions(data, i, uint64(len(*m.To)))
		i += copy(data[i:], *m.To)
	}
	if m.LogSource != nil {
		data[i] = 0x22
		i++
		i = encodeVarintActions(data, i, uint64(len(*m.LogSource)))
		i += copy(data[i:], *m.LogSource)
	}
	if m.User != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintActions(data, i, uint64(len(*m.User)))
		i += copy(data[i:], *m.User)
	}
	return i, nil
}

func (m *RunAction) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RunAction) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Path != nil {
		data[i] = 0xa
		i++
		i = encodeVarintActions(data, i, uint64(len(*m.Path)))
		i += copy(data[i:], *m.Path)
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			data[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.Dir != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintActions(data, i, uint64(len(*m.Dir)))
		i += copy(data[i:], *m.Dir)
	}
	if len(m.Env) > 0 {
		for _, msg := range m.Env {
			data[i] = 0x22
			i++
			i = encodeVarintActions(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ResourceLimits != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintActions(data, i, uint64(m.ResourceLimits.Size()))
		n10, err := m.ResourceLimits.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.User != nil {
		data[i] = 0x32
		i++
		i = encodeVarintActions(data, i, uint64(len(*m.User)))
		i += copy(data[i:], *m.User)
	}
	if m.LogSource != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintActions(data, i, uint64(len(*m.LogSource)))
		i += copy(data[i:], *m.LogSource)
	}
	return i, nil
}

func (m *TimeoutAction) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TimeoutAction) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Action != nil {
		data[i] = 0xa
		i++
		i = encodeVarintActions(data, i, uint64(m.Action.Size()))
		n11, err := m.Action.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.Timeout != nil {
		data[i] = 0x10
		i++
		i = encodeVarintActions(data, i, uint64(*m.Timeout))
	}
	if m.LogSource != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintActions(data, i, uint64(len(*m.LogSource)))
		i += copy(data[i:], *m.LogSource)
	}
	return i, nil
}

func (m *EmitProgressAction) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *EmitProgressAction) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Action != nil {
		data[i] = 0xa
		i++
		i = encodeVarintActions(data, i, uint64(m.Action.Size()))
		n12, err := m.Action.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.StartMessage != nil {
		data[i] = 0x12
		i++
		i = encodeVarintActions(data, i, uint64(len(*m.StartMessage)))
		i += copy(data[i:], *m.StartMessage)
	}
	if m.SuccessMessage != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintActions(data, i, uint64(len(*m.SuccessMessage)))
		i += copy(data[i:], *m.SuccessMessage)
	}
	if m.FailureMessagePrefix != nil {
		data[i] = 0x22
		i++
		i = encodeVarintActions(data, i, uint64(len(*m.FailureMessagePrefix)))
		i += copy(data[i:], *m.FailureMessagePrefix)
	}
	if m.LogSource != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintActions(data, i, uint64(len(*m.LogSource)))
		i += copy(data[i:], *m.LogSource)
	}
	return i, nil
}

func (m *TryAction) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TryAction) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Action != nil {
		data[i] = 0xa
		i++
		i = encodeVarintActions(data, i, uint64(m.Action.Size()))
		n13, err := m.Action.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.LogSource != nil {
		data[i] = 0x12
		i++
		i = encodeVarintActions(data, i, uint64(len(*m.LogSource)))
		i += copy(data[i:], *m.LogSource)
	}
	return i, nil
}

func (m *ParallelAction) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ParallelAction) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Actions) > 0 {
		for _, msg := range m.Actions {
			data[i] = 0xa
			i++
			i = encodeVarintActions(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.LogSource != nil {
		data[i] = 0x12
		i++
		i = encodeVarintActions(data, i, uint64(len(*m.LogSource)))
		i += copy(data[i:], *m.LogSource)
	}
	return i, nil
}

func (m *SerialAction) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SerialAction) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Actions) > 0 {
		for _, msg := range m.Actions {
			data[i] = 0xa
			i++
			i = encodeVarintActions(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.LogSource != nil {
		data[i] = 0x12
		i++
		i = encodeVarintActions(data, i, uint64(len(*m.LogSource)))
		i += copy(data[i:], *m.LogSource)
	}
	return i, nil
}

func (m *CodependentAction) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CodependentAction) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Actions) > 0 {
		for _, msg := range m.Actions {
			data[i] = 0xa
			i++
			i = encodeVarintActions(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.LogSource != nil {
		data[i] = 0x12
		i++
		i = encodeVarintActions(data, i, uint64(len(*m.LogSource)))
		i += copy(data[i:], *m.LogSource)
	}
	return i, nil
}

func (m *ResourceLimits) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ResourceLimits) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Nofile != nil {
		data[i] = 0x8
		i++
		i = encodeVarintActions(data, i, uint64(*m.Nofile))
	}
	return i, nil
}

func encodeFixed64Actions(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Actions(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintActions(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (this *Action) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Action)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.DownloadAction.Equal(that1.DownloadAction) {
		return false
	}
	if !this.UploadAction.Equal(that1.UploadAction) {
		return false
	}
	if !this.RunAction.Equal(that1.RunAction) {
		return false
	}
	if !this.TimeoutAction.Equal(that1.TimeoutAction) {
		return false
	}
	if !this.EmitProgressAction.Equal(that1.EmitProgressAction) {
		return false
	}
	if !this.TryAction.Equal(that1.TryAction) {
		return false
	}
	if !this.ParallelAction.Equal(that1.ParallelAction) {
		return false
	}
	if !this.SerialAction.Equal(that1.SerialAction) {
		return false
	}
	if !this.CodependentAction.Equal(that1.CodependentAction) {
		return false
	}
	return true
}
func (this *DownloadAction) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DownloadAction)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Artifact != nil && that1.Artifact != nil {
		if *this.Artifact != *that1.Artifact {
			return false
		}
	} else if this.Artifact != nil {
		return false
	} else if that1.Artifact != nil {
		return false
	}
	if this.From != nil && that1.From != nil {
		if *this.From != *that1.From {
			return false
		}
	} else if this.From != nil {
		return false
	} else if that1.From != nil {
		return false
	}
	if this.To != nil && that1.To != nil {
		if *this.To != *that1.To {
			return false
		}
	} else if this.To != nil {
		return false
	} else if that1.To != nil {
		return false
	}
	if this.CacheKey != nil && that1.CacheKey != nil {
		if *this.CacheKey != *that1.CacheKey {
			return false
		}
	} else if this.CacheKey != nil {
		return false
	} else if that1.CacheKey != nil {
		return false
	}
	if this.LogSource != nil && that1.LogSource != nil {
		if *this.LogSource != *that1.LogSource {
			return false
		}
	} else if this.LogSource != nil {
		return false
	} else if that1.LogSource != nil {
		return false
	}
	if this.User != nil && that1.User != nil {
		if *this.User != *that1.User {
			return false
		}
	} else if this.User != nil {
		return false
	} else if that1.User != nil {
		return false
	}
	return true
}
func (this *UploadAction) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*UploadAction)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Artifact != nil && that1.Artifact != nil {
		if *this.Artifact != *that1.Artifact {
			return false
		}
	} else if this.Artifact != nil {
		return false
	} else if that1.Artifact != nil {
		return false
	}
	if this.From != nil && that1.From != nil {
		if *this.From != *that1.From {
			return false
		}
	} else if this.From != nil {
		return false
	} else if that1.From != nil {
		return false
	}
	if this.To != nil && that1.To != nil {
		if *this.To != *that1.To {
			return false
		}
	} else if this.To != nil {
		return false
	} else if that1.To != nil {
		return false
	}
	if this.LogSource != nil && that1.LogSource != nil {
		if *this.LogSource != *that1.LogSource {
			return false
		}
	} else if this.LogSource != nil {
		return false
	} else if that1.LogSource != nil {
		return false
	}
	if this.User != nil && that1.User != nil {
		if *this.User != *that1.User {
			return false
		}
	} else if this.User != nil {
		return false
	} else if that1.User != nil {
		return false
	}
	return true
}
func (this *RunAction) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RunAction)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Path != nil && that1.Path != nil {
		if *this.Path != *that1.Path {
			return false
		}
	} else if this.Path != nil {
		return false
	} else if that1.Path != nil {
		return false
	}
	if len(this.Args) != len(that1.Args) {
		return false
	}
	for i := range this.Args {
		if this.Args[i] != that1.Args[i] {
			return false
		}
	}
	if this.Dir != nil && that1.Dir != nil {
		if *this.Dir != *that1.Dir {
			return false
		}
	} else if this.Dir != nil {
		return false
	} else if that1.Dir != nil {
		return false
	}
	if len(this.Env) != len(that1.Env) {
		return false
	}
	for i := range this.Env {
		if !this.Env[i].Equal(that1.Env[i]) {
			return false
		}
	}
	if !this.ResourceLimits.Equal(that1.ResourceLimits) {
		return false
	}
	if this.User != nil && that1.User != nil {
		if *this.User != *that1.User {
			return false
		}
	} else if this.User != nil {
		return false
	} else if that1.User != nil {
		return false
	}
	if this.LogSource != nil && that1.LogSource != nil {
		if *this.LogSource != *that1.LogSource {
			return false
		}
	} else if this.LogSource != nil {
		return false
	} else if that1.LogSource != nil {
		return false
	}
	return true
}
func (this *TimeoutAction) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TimeoutAction)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Action.Equal(that1.Action) {
		return false
	}
	if this.Timeout != nil && that1.Timeout != nil {
		if *this.Timeout != *that1.Timeout {
			return false
		}
	} else if this.Timeout != nil {
		return false
	} else if that1.Timeout != nil {
		return false
	}
	if this.LogSource != nil && that1.LogSource != nil {
		if *this.LogSource != *that1.LogSource {
			return false
		}
	} else if this.LogSource != nil {
		return false
	} else if that1.LogSource != nil {
		return false
	}
	return true
}
func (this *EmitProgressAction) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*EmitProgressAction)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Action.Equal(that1.Action) {
		return false
	}
	if this.StartMessage != nil && that1.StartMessage != nil {
		if *this.StartMessage != *that1.StartMessage {
			return false
		}
	} else if this.StartMessage != nil {
		return false
	} else if that1.StartMessage != nil {
		return false
	}
	if this.SuccessMessage != nil && that1.SuccessMessage != nil {
		if *this.SuccessMessage != *that1.SuccessMessage {
			return false
		}
	} else if this.SuccessMessage != nil {
		return false
	} else if that1.SuccessMessage != nil {
		return false
	}
	if this.FailureMessagePrefix != nil && that1.FailureMessagePrefix != nil {
		if *this.FailureMessagePrefix != *that1.FailureMessagePrefix {
			return false
		}
	} else if this.FailureMessagePrefix != nil {
		return false
	} else if that1.FailureMessagePrefix != nil {
		return false
	}
	if this.LogSource != nil && that1.LogSource != nil {
		if *this.LogSource != *that1.LogSource {
			return false
		}
	} else if this.LogSource != nil {
		return false
	} else if that1.LogSource != nil {
		return false
	}
	return true
}
func (this *TryAction) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TryAction)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Action.Equal(that1.Action) {
		return false
	}
	if this.LogSource != nil && that1.LogSource != nil {
		if *this.LogSource != *that1.LogSource {
			return false
		}
	} else if this.LogSource != nil {
		return false
	} else if that1.LogSource != nil {
		return false
	}
	return true
}
func (this *ParallelAction) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ParallelAction)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Actions) != len(that1.Actions) {
		return false
	}
	for i := range this.Actions {
		if !this.Actions[i].Equal(that1.Actions[i]) {
			return false
		}
	}
	if this.LogSource != nil && that1.LogSource != nil {
		if *this.LogSource != *that1.LogSource {
			return false
		}
	} else if this.LogSource != nil {
		return false
	} else if that1.LogSource != nil {
		return false
	}
	return true
}
func (this *SerialAction) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*SerialAction)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Actions) != len(that1.Actions) {
		return false
	}
	for i := range this.Actions {
		if !this.Actions[i].Equal(that1.Actions[i]) {
			return false
		}
	}
	if this.LogSource != nil && that1.LogSource != nil {
		if *this.LogSource != *that1.LogSource {
			return false
		}
	} else if this.LogSource != nil {
		return false
	} else if that1.LogSource != nil {
		return false
	}
	return true
}
func (this *CodependentAction) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CodependentAction)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Actions) != len(that1.Actions) {
		return false
	}
	for i := range this.Actions {
		if !this.Actions[i].Equal(that1.Actions[i]) {
			return false
		}
	}
	if this.LogSource != nil && that1.LogSource != nil {
		if *this.LogSource != *that1.LogSource {
			return false
		}
	} else if this.LogSource != nil {
		return false
	} else if that1.LogSource != nil {
		return false
	}
	return true
}
func (this *ResourceLimits) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ResourceLimits)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Nofile != nil && that1.Nofile != nil {
		if *this.Nofile != *that1.Nofile {
			return false
		}
	} else if this.Nofile != nil {
		return false
	} else if that1.Nofile != nil {
		return false
	}
	return true
}
